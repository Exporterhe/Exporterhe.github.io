<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>临时表的产生场景</title>
    <link href="/2025/03/29/%E4%B8%B4%E6%97%B6%E8%A1%A8%E7%9A%84%E4%BA%A7%E7%94%9F%E5%9C%BA%E6%99%AF/"/>
    <url>/2025/03/29/%E4%B8%B4%E6%97%B6%E8%A1%A8%E7%9A%84%E4%BA%A7%E7%94%9F%E5%9C%BA%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<p>临时表通常在数据库操作中用于临时存储中间结果，以便简化复杂查询或优化性能。以下是一些常见场景：</p><hr><h3 id="1-复杂查询处理"><a href="#1-复杂查询处理" class="headerlink" title="1. 复杂查询处理"></a>1. <strong>复杂查询处理</strong></h3><p>• <strong>场景</strong>：涉及多步骤的查询（如多层子查询、多表 JOIN）时，数据库可能生成临时表存储中间结果。<br>• <strong>示例</strong>：统计每个地区的销售总额，可能需要先按地区汇总订单数据到临时表，再计算总和。</p><hr><h3 id="2-排序与分组（ORDER-BY-GROUP-BY）"><a href="#2-排序与分组（ORDER-BY-GROUP-BY）" class="headerlink" title="2. 排序与分组（ORDER BY &#x2F; GROUP BY）"></a>2. <strong>排序与分组（ORDER BY &#x2F; GROUP BY）</strong></h3><p>• <strong>场景</strong>：对大量数据排序或分组时，数据库可能用临时表存放中间结果。<br>• <strong>示例</strong>：<code>SELECT * FROM sales ORDER BY amount DESC LIMIT 100</code>，临时表可能用于存储排序后的结果。</p><hr><h3 id="3-窗口函数（Window-Functions）"><a href="#3-窗口函数（Window-Functions）" class="headerlink" title="3. 窗口函数（Window Functions）"></a>3. <strong>窗口函数（Window Functions）</strong></h3><p>• <strong>场景</strong>：使用 <code>ROW_NUMBER()</code>, <code>RANK()</code> 等窗口函数时，可能需要临时表存储中间计算结果。<br>• <strong>示例</strong>：按销售额排名时，临时表可暂存分区和排序后的数据。</p><hr><h3 id="4-数据去重（DISTINCT-GROUP-BY）"><a href="#4-数据去重（DISTINCT-GROUP-BY）" class="headerlink" title="4. 数据去重（DISTINCT &#x2F; GROUP BY）"></a>4. <strong>数据去重（DISTINCT &#x2F; GROUP BY）</strong></h3><p>• <strong>场景</strong>：去重操作可能生成临时表存储唯一值。<br>• <strong>示例</strong>：<code>SELECT DISTINCT user_id FROM orders</code> 会将去重后的数据存入临时表。</p><hr><h3 id="5-优化子查询"><a href="#5-优化子查询" class="headerlink" title="5. 优化子查询"></a>5. <strong>优化子查询</strong></h3><p>• <strong>场景</strong>：复杂子查询可能被优化器转换为临时表，避免重复执行。<br>• <strong>示例</strong>：多次引用的子查询（如 <code>WHERE id IN (SELECT ...)</code>）可能生成临时表提升性能。</p><hr><h3 id="6-UNION-UNION-ALL-操作"><a href="#6-UNION-UNION-ALL-操作" class="headerlink" title="6. UNION &#x2F; UNION ALL 操作"></a>6. <strong>UNION &#x2F; UNION ALL 操作</strong></h3><p>• <strong>场景</strong>：合并多个查询结果时，临时表存储各结果集后再合并。<br>• <strong>示例</strong>：<code>SELECT a FROM t1 UNION SELECT b FROM t2</code> 会先将两个查询结果存入临时表。</p><hr><h3 id="7-会话或事务中的临时存储"><a href="#7-会话或事务中的临时存储" class="headerlink" title="7. 会话或事务中的临时存储"></a>7. <strong>会话或事务中的临时存储</strong></h3><p>• <strong>场景</strong>：在会话或事务中显式创建临时表，存储中间数据供后续操作使用。<br>• <strong>示例</strong>：用户会话中手动创建临时表存储计算过程中的数据。</p><hr><h3 id="8-内存不足时的磁盘写入"><a href="#8-内存不足时的磁盘写入" class="headerlink" title="8. 内存不足时的磁盘写入"></a>8. <strong>内存不足时的磁盘写入</strong></h3><p>• <strong>场景</strong>：当中间结果过大超出内存限制，数据库将数据写入磁盘临时表。<br>• <strong>示例</strong>：处理超大型数据集时，临时表可能存储在磁盘而非内存。</p><hr><h3 id="9-跨数据库或跨实例查询"><a href="#9-跨数据库或跨实例查询" class="headerlink" title="9. 跨数据库或跨实例查询"></a>9. <strong>跨数据库或跨实例查询</strong></h3><p>• <strong>场景</strong>：涉及多个数据库或外部数据源的查询，临时表暂存数据以便关联。<br>• <strong>示例</strong>：从不同数据库实例提取数据并关联时，临时表整合数据。</p><hr><h3 id="10-游标或存储过程"><a href="#10-游标或存储过程" class="headerlink" title="10. 游标或存储过程"></a>10. <strong>游标或存储过程</strong></h3><p>• <strong>场景</strong>：在存储过程或游标处理中，临时表用于分步处理数据。<br>• <strong>示例</strong>：逐行处理数据时，临时表暂存批量处理的结果。</p><hr><h3 id="临时表的生命周期"><a href="#临时表的生命周期" class="headerlink" title="临时表的生命周期"></a>临时表的生命周期</h3><p>• <strong>会话级临时表</strong>：仅存在于当前会话，会话结束自动删除。<br>• <strong>事务级临时表</strong>：仅存在于当前事务，事务提交后自动删除。</p><hr><p>通过合理使用临时表，可以显著提升复杂查询的效率，但需注意其可能带来的磁盘 I&#x2F;O 开销。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>synchronized为什么会有数据不一致的情况</title>
    <link href="/2025/03/29/synchronized%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E6%83%85%E5%86%B5/"/>
    <url>/2025/03/29/synchronized%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E6%83%85%E5%86%B5/</url>
    
    <content type="html"><![CDATA[<p>在 Java 中，<code>synchronized</code> 关键字本意是解决多线程并发问题，<strong>保证线程安全</strong>，但如果在使用过程中设计不当，仍可能导致数据不一致。以下是 <code>synchronized</code> 可能导致数据不一致的常见原因：</p><hr><h3 id="1-同步范围不足（部分代码未同步）"><a href="#1-同步范围不足（部分代码未同步）" class="headerlink" title="1. 同步范围不足（部分代码未同步）"></a>1. <strong>同步范围不足（部分代码未同步）</strong></h3><p>• <strong>问题</strong>：如果只对部分操作加锁，而其他线程能绕过同步代码修改共享数据，会导致数据不一致。<br>• <strong>示例</strong>：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        count++;  <span class="hljs-comment">// 同步的代码块</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">// 未同步的方法</span><br>        <span class="hljs-keyword">return</span> count;        <span class="hljs-comment">// 可能读到脏数据</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>  • <strong>原因</strong>：<code>getCount()</code> 未加锁，其他线程可能在 <code>increment()</code> 执行期间读取到未更新的值。</p><hr><h3 id="2-未保证操作的原子性"><a href="#2-未保证操作的原子性" class="headerlink" title="2. 未保证操作的原子性"></a>2. <strong>未保证操作的原子性</strong></h3><p>• <strong>问题</strong>：即使某个方法是同步的，如果多个相关操作未作为一个整体加锁，仍可能导致中间状态暴露。<br>• <strong>示例</strong>：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">balance</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br><br>    <span class="hljs-comment">// 转账操作未整体加锁</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Account target, <span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-built_in">this</span>.balance -= amount;<br>        &#125;<br>        <span class="hljs-comment">// 此处未同步，其他线程可能修改 target.balance</span><br>        <span class="hljs-keyword">synchronized</span> (target) &#123;<br>            target.balance += amount;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>  • <strong>原因</strong>：转账操作被拆分为两个独立的同步块，可能导致中间状态（如 <code>this.balance</code> 已扣款，但 <code>target.balance</code> 未到账）。</p><hr><h3 id="3-锁对象不一致"><a href="#3-锁对象不一致" class="headerlink" title="3. 锁对象不一致"></a>3. <strong>锁对象不一致</strong></h3><p>• <strong>问题</strong>：不同线程使用不同的锁对象，导致同步失效。<br>• <strong>示例</strong>：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> value;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock1) &#123;  <span class="hljs-comment">// 使用 lock1 加锁</span><br>            value++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock2) &#123;  <span class="hljs-comment">// 使用 lock2 加锁</span><br>            <span class="hljs-keyword">return</span> value;       <span class="hljs-comment">// 锁不一致，无法互斥</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>  • <strong>原因</strong>：<code>update()</code> 和 <code>get()</code> 使用不同的锁对象，无法保证互斥访问。</p><hr><h3 id="4-静态与非静态锁混淆"><a href="#4-静态与非静态锁混淆" class="headerlink" title="4. 静态与非静态锁混淆"></a>4. <strong>静态与非静态锁混淆</strong></h3><p>• <strong>问题</strong>：静态方法使用 <code>Class</code> 锁，实例方法使用对象锁，可能导致非预期的并发访问。<br>• <strong>示例</strong>：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">// 类锁</span><br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">// 对象锁</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>  • <strong>原因</strong>：<code>getInstance()</code> 使用类锁，<code>doSomething()</code> 使用对象锁，两者不互斥，可能导致实例未完全初始化就被调用。</p><hr><h3 id="5-可见性问题未解决"><a href="#5-可见性问题未解决" class="headerlink" title="5. 可见性问题未解决"></a>5. <strong>可见性问题未解决</strong></h3><p>• <strong>问题</strong>：<code>synchronized</code> 能保证可见性，但如果共享变量在同步块外被修改，可能导致不一致。<br>• <strong>示例</strong>：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VisibilityDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 未用 volatile</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            flag = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 同步块内修改</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reader</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (flag) &#123;  <span class="hljs-comment">// 未加锁，可能看不到最新值</span><br>            System.out.println(<span class="hljs-string">&quot;Flag is true&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>  • <strong>原因</strong>：<code>reader()</code> 未加锁，可能因 JVM 内存模型（如缓存一致性）读取到旧值。</p><hr><h3 id="6-锁未覆盖复合操作"><a href="#6-锁未覆盖复合操作" class="headerlink" title="6. 锁未覆盖复合操作"></a>6. <strong>锁未覆盖复合操作</strong></h3><p>• <strong>问题</strong>：多个相关操作未作为一个原子操作加锁。<br>• <strong>示例</strong>：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cache</span> &#123;<br>    <span class="hljs-keyword">private</span> Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String key, String value)</span> &#123;<br>        map.put(key, value);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-keyword">return</span> map.containsKey(key);  <span class="hljs-comment">// 未加锁，可能返回过期结果</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>  • <strong>原因</strong>：<code>contains()</code> 未加锁，可能读到 <code>add()</code> 尚未完成的状态。</p><hr><h3 id="7-对象逸出（Improper-Publication）"><a href="#7-对象逸出（Improper-Publication）" class="headerlink" title="7. 对象逸出（Improper Publication）"></a>7. <strong>对象逸出（Improper Publication）</strong></h3><p>• <strong>问题</strong>：对象未完全构造完成就被其他线程访问，即使后续操作同步，初始状态可能不一致。<br>• <strong>示例</strong>：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnsafePublish</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> value;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UnsafePublish</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-built_in">this</span>.value);  <span class="hljs-comment">// 可能读到未初始化的 0</span><br>        &#125;).start();<br>        value = <span class="hljs-number">42</span>;  <span class="hljs-comment">// 在构造函数中赋值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>  • <strong>原因</strong>：构造函数中启动的线程可能看到未完全初始化的对象（<code>value</code> 未被赋值为 42）。</p><hr><h3 id="8-锁粒度不当"><a href="#8-锁粒度不当" class="headerlink" title="8. 锁粒度不当"></a>8. <strong>锁粒度不当</strong></h3><p>• <strong>问题</strong>：锁粒度过大或过小，导致性能问题或逻辑错误。<br>• <strong>示例</strong>：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CoarseLock</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> a, b;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            a++;<br>            b--;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-keyword">return</span> a + b;  <span class="hljs-comment">// 锁粒度过大，可能导致不必要的阻塞</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>  • <strong>优化</strong>：若 <code>a</code> 和 <code>b</code> 可独立操作，拆分为细粒度锁可能更高效。</p><hr><h3 id="9-线程间协作问题（如-wait-notify）"><a href="#9-线程间协作问题（如-wait-notify）" class="headerlink" title="9. 线程间协作问题（如 wait&#x2F;notify）"></a>9. <strong>线程间协作问题（如 wait&#x2F;notify）</strong></h3><p>• <strong>问题</strong>：使用 <code>wait()</code> 或 <code>notify()</code> 时未正确同步，可能导致虚假唤醒或条件失效。<br>• <strong>示例</strong>：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskQueue</span> &#123;<br>    <span class="hljs-keyword">private</span> Queue&lt;Task&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Task task)</span> &#123;<br>        queue.add(task);<br>        notify();  <span class="hljs-comment">// 通知等待线程</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Task <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>            wait();  <span class="hljs-comment">// 未在循环中检查条件，可能虚假唤醒</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> queue.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>  • <strong>正确写法</strong>：<code>while (queue.isEmpty())</code> 代替 <code>if</code>，防止虚假唤醒。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>synchronized</code> 本身是线程安全的工具，但需满足以下条件才能保证数据一致性：</p><ol><li><strong>原子性</strong>：所有相关操作必须作为一个整体加锁。</li><li><strong>可见性</strong>：通过锁的进入和退出强制刷新内存。</li><li><strong>锁一致性</strong>：所有线程必须使用同一个锁对象。</li><li><strong>正确的线程协作</strong>：合理使用 <code>wait()</code>&#x2F;<code>notify()</code>。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/03/26/hello-world/"/>
    <url>/2025/03/26/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
