<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>synchronized为什么会有数据不一致的情况</title>
    <link href="/2025/03/29/synchronized%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E6%83%85%E5%86%B5/"/>
    <url>/2025/03/29/synchronized%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E6%83%85%E5%86%B5/</url>
    
    <content type="html"><![CDATA[<p>在 Java 中，<code>synchronized</code> 关键字本意是解决多线程并发问题，<strong>保证线程安全</strong>，但如果在使用过程中设计不当，仍可能导致数据不一致。以下是 <code>synchronized</code> 可能导致数据不一致的常见原因：</p><hr><h3 id="1-同步范围不足（部分代码未同步）"><a href="#1-同步范围不足（部分代码未同步）" class="headerlink" title="1. 同步范围不足（部分代码未同步）"></a>1. <strong>同步范围不足（部分代码未同步）</strong></h3><p>• <strong>问题</strong>：如果只对部分操作加锁，而其他线程能绕过同步代码修改共享数据，会导致数据不一致。<br>• <strong>示例</strong>：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        count++;  <span class="hljs-comment">// 同步的代码块</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">// 未同步的方法</span><br>        <span class="hljs-keyword">return</span> count;        <span class="hljs-comment">// 可能读到脏数据</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>  • <strong>原因</strong>：<code>getCount()</code> 未加锁，其他线程可能在 <code>increment()</code> 执行期间读取到未更新的值。</p><hr><h3 id="2-未保证操作的原子性"><a href="#2-未保证操作的原子性" class="headerlink" title="2. 未保证操作的原子性"></a>2. <strong>未保证操作的原子性</strong></h3><p>• <strong>问题</strong>：即使某个方法是同步的，如果多个相关操作未作为一个整体加锁，仍可能导致中间状态暴露。<br>• <strong>示例</strong>：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">balance</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br><br>    <span class="hljs-comment">// 转账操作未整体加锁</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Account target, <span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-built_in">this</span>.balance -= amount;<br>        &#125;<br>        <span class="hljs-comment">// 此处未同步，其他线程可能修改 target.balance</span><br>        <span class="hljs-keyword">synchronized</span> (target) &#123;<br>            target.balance += amount;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>  • <strong>原因</strong>：转账操作被拆分为两个独立的同步块，可能导致中间状态（如 <code>this.balance</code> 已扣款，但 <code>target.balance</code> 未到账）。</p><hr><h3 id="3-锁对象不一致"><a href="#3-锁对象不一致" class="headerlink" title="3. 锁对象不一致"></a>3. <strong>锁对象不一致</strong></h3><p>• <strong>问题</strong>：不同线程使用不同的锁对象，导致同步失效。<br>• <strong>示例</strong>：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> value;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock1) &#123;  <span class="hljs-comment">// 使用 lock1 加锁</span><br>            value++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock2) &#123;  <span class="hljs-comment">// 使用 lock2 加锁</span><br>            <span class="hljs-keyword">return</span> value;       <span class="hljs-comment">// 锁不一致，无法互斥</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>  • <strong>原因</strong>：<code>update()</code> 和 <code>get()</code> 使用不同的锁对象，无法保证互斥访问。</p><hr><h3 id="4-静态与非静态锁混淆"><a href="#4-静态与非静态锁混淆" class="headerlink" title="4. 静态与非静态锁混淆"></a>4. <strong>静态与非静态锁混淆</strong></h3><p>• <strong>问题</strong>：静态方法使用 <code>Class</code> 锁，实例方法使用对象锁，可能导致非预期的并发访问。<br>• <strong>示例</strong>：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">// 类锁</span><br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;  <span class="hljs-comment">// 对象锁</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>  • <strong>原因</strong>：<code>getInstance()</code> 使用类锁，<code>doSomething()</code> 使用对象锁，两者不互斥，可能导致实例未完全初始化就被调用。</p><hr><h3 id="5-可见性问题未解决"><a href="#5-可见性问题未解决" class="headerlink" title="5. 可见性问题未解决"></a>5. <strong>可见性问题未解决</strong></h3><p>• <strong>问题</strong>：<code>synchronized</code> 能保证可见性，但如果共享变量在同步块外被修改，可能导致不一致。<br>• <strong>示例</strong>：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VisibilityDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 未用 volatile</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            flag = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 同步块内修改</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reader</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (flag) &#123;  <span class="hljs-comment">// 未加锁，可能看不到最新值</span><br>            System.out.println(<span class="hljs-string">&quot;Flag is true&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>  • <strong>原因</strong>：<code>reader()</code> 未加锁，可能因 JVM 内存模型（如缓存一致性）读取到旧值。</p><hr><h3 id="6-锁未覆盖复合操作"><a href="#6-锁未覆盖复合操作" class="headerlink" title="6. 锁未覆盖复合操作"></a>6. <strong>锁未覆盖复合操作</strong></h3><p>• <strong>问题</strong>：多个相关操作未作为一个原子操作加锁。<br>• <strong>示例</strong>：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cache</span> &#123;<br>    <span class="hljs-keyword">private</span> Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String key, String value)</span> &#123;<br>        map.put(key, value);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-keyword">return</span> map.containsKey(key);  <span class="hljs-comment">// 未加锁，可能返回过期结果</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>  • <strong>原因</strong>：<code>contains()</code> 未加锁，可能读到 <code>add()</code> 尚未完成的状态。</p><hr><h3 id="7-对象逸出（Improper-Publication）"><a href="#7-对象逸出（Improper-Publication）" class="headerlink" title="7. 对象逸出（Improper Publication）"></a>7. <strong>对象逸出（Improper Publication）</strong></h3><p>• <strong>问题</strong>：对象未完全构造完成就被其他线程访问，即使后续操作同步，初始状态可能不一致。<br>• <strong>示例</strong>：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnsafePublish</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> value;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UnsafePublish</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-built_in">this</span>.value);  <span class="hljs-comment">// 可能读到未初始化的 0</span><br>        &#125;).start();<br>        value = <span class="hljs-number">42</span>;  <span class="hljs-comment">// 在构造函数中赋值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>  • <strong>原因</strong>：构造函数中启动的线程可能看到未完全初始化的对象（<code>value</code> 未被赋值为 42）。</p><hr><h3 id="8-锁粒度不当"><a href="#8-锁粒度不当" class="headerlink" title="8. 锁粒度不当"></a>8. <strong>锁粒度不当</strong></h3><p>• <strong>问题</strong>：锁粒度过大或过小，导致性能问题或逻辑错误。<br>• <strong>示例</strong>：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CoarseLock</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> a, b;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            a++;<br>            b--;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-keyword">return</span> a + b;  <span class="hljs-comment">// 锁粒度过大，可能导致不必要的阻塞</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>  • <strong>优化</strong>：若 <code>a</code> 和 <code>b</code> 可独立操作，拆分为细粒度锁可能更高效。</p><hr><h3 id="9-线程间协作问题（如-wait-notify）"><a href="#9-线程间协作问题（如-wait-notify）" class="headerlink" title="9. 线程间协作问题（如 wait&#x2F;notify）"></a>9. <strong>线程间协作问题（如 wait&#x2F;notify）</strong></h3><p>• <strong>问题</strong>：使用 <code>wait()</code> 或 <code>notify()</code> 时未正确同步，可能导致虚假唤醒或条件失效。<br>• <strong>示例</strong>：<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskQueue</span> &#123;<br>    <span class="hljs-keyword">private</span> Queue&lt;Task&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Task task)</span> &#123;<br>        queue.add(task);<br>        notify();  <span class="hljs-comment">// 通知等待线程</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Task <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>            wait();  <span class="hljs-comment">// 未在循环中检查条件，可能虚假唤醒</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> queue.remove();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>  • <strong>正确写法</strong>：<code>while (queue.isEmpty())</code> 代替 <code>if</code>，防止虚假唤醒。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>synchronized</code> 本身是线程安全的工具，但需满足以下条件才能保证数据一致性：</p><ol><li><strong>原子性</strong>：所有相关操作必须作为一个整体加锁。</li><li><strong>可见性</strong>：通过锁的进入和退出强制刷新内存。</li><li><strong>锁一致性</strong>：所有线程必须使用同一个锁对象。</li><li><strong>正确的线程协作</strong>：合理使用 <code>wait()</code>&#x2F;<code>notify()</code>。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>centos环境下部署ELK</title>
    <link href="/2025/03/26/centos%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%83%A8%E7%BD%B2ELK/"/>
    <url>/2025/03/26/centos%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%83%A8%E7%BD%B2ELK/</url>
    
    <content type="html"><![CDATA[<p>ELK是一种用于处理日志数据和分析的开源软件套件，由Elasticsearch、Logstash和Kibana组成。在centos环境下部署ELK需要以下步骤：<br>1.安装Java环境<br>ELK需要使用Java环境，因此需要先安装Java环境。可以使用以下命令安装：<br>sudo yum install java<br>2.安装Elasticsearch<br>Elasticsearch是一个分布式搜索和分析引擎，用于存储和查询数据。可以使用以下步骤安装Elasticsearch：<br>sudo rpm –import <a href="https://artifacts.elastic.co/GPG-KEY-elasticsearch">https://artifacts.elastic.co/GPG-KEY-elasticsearch</a><br>sudo vi &#x2F;etc&#x2F;yum.repos.d&#x2F;elasticsearch.repo<br>复制以下文本到elasticsearch.repo文件中：<br>[elasticsearch-7.x]<br>name&#x3D;Elasticsearch repository for 7.x packages<br>baseurl&#x3D;<a href="https://artifacts.elastic.co/packages/7.x/yum">https://artifacts.elastic.co/packages/7.x/yum</a><br>gpgcheck&#x3D;1<br>gpgkey&#x3D;<a href="https://artifacts.elastic.co/GPG-KEY-elasticsearch">https://artifacts.elastic.co/GPG-KEY-elasticsearch</a><br>enabled&#x3D;1<br>autorefresh&#x3D;1<br>type&#x3D;rpm-md<br>保存并关闭文件后，使用以下命令安装：<br>sudo yum install elasticsearch<br>3.配置Elasticsearch<br>安装完成后，需要编辑Elasticsearch配置文件&#x2F;etc&#x2F;elasticsearch&#x2F;elasticsearch.yml。在该文件中，可以设置Elasticsearch监听的IP地址和端口等参数。例如，可以添加以下内容：<br>network.host: 0.0.0.0<br>http.port: 9200<br>保存并关闭文件后，使用以下命令启动Elasticsearch：<br>sudo systemctl start elasticsearch<br>sudo systemctl enable elasticsearch</p><p>sudo systemctl status elasticsearch –查看服务运行日志<br>bootstrap check failure [1] of [1]: the default discovery settings are unsuitable for production use; at least one of [discovery.seed_hosts, discovery.seed_providers, cluster.initial_master_nodes] must be configured<br>这个问题通常是因为在Elasticsearch中使用了默认的发现设置，不适合生产环境使用。您需要根据您的具体环境配置至少一个发现设置。<br>以下是解决问题的步骤：<br>1.打开 Elasticsearch 配置文件 (&#x2F;etc&#x2F;elasticsearch&#x2F;elasticsearch.yml)。<br>2.找到以下参数之一：discovery.seed_hosts, discovery.seed_providers 或 cluster.initial_master_nodes。<br>3.配置至少一个参数。例如，您可以在配置文件中添加以下行以设置discovery.seed_hosts：<br>discovery.seed_hosts: [“host”, “host”]</p><p>4.保存文件并重新启动 Elasticsearch。<br>5.验证 Elasticsearch 是否可以正常工作。您可以通过执行如下命令来检查 Elasticsearch 的健康状况：<br>curl -XGET ‘<a href="http://localhost:9200/_cluster/health?pretty=true%E2%80%99">http://localhost:9200/_cluster/health?pretty=true’</a></p><p>如果 Elasticsearch 健康状态显示为 “green”或 “yellow”，则表示 Elasticsearch 可以正常工作。<br>希望这可以帮助您解决问题。<br>4.安装Logstash<br>Logstash是一个数据收集和转换工具，用于将各种数据源的数据发送到Elasticsearch进行分析和查询。可以使用以下步骤安装Logstash：<br>sudo rpm –import <a href="https://artifacts.elastic.co/GPG-KEY-elasticsearch">https://artifacts.elastic.co/GPG-KEY-elasticsearch</a><br>sudo vi &#x2F;etc&#x2F;yum.repos.d&#x2F;logstash.repo<br>复制以下文本到logstash.repo文件中：<br>[logstash-7.x]<br>name&#x3D;Elastic repository for 7.x packages<br>baseurl&#x3D;<a href="https://artifacts.elastic.co/packages/7.x/yum">https://artifacts.elastic.co/packages/7.x/yum</a><br>gpgcheck&#x3D;1<br>gpgkey&#x3D;<a href="https://artifacts.elastic.co/GPG-KEY-elasticsearch">https://artifacts.elastic.co/GPG-KEY-elasticsearch</a><br>enabled&#x3D;1<br>autorefresh&#x3D;1<br>type&#x3D;rpm-md<br>保存并关闭文件后，使用以下命令安装：<br>sudo yum install logstash<br>5.配置Logstash<br>安装完成后，需要编辑Logstash配置文件&#x2F;etc&#x2F;logstash&#x2F;conf.d&#x2F;logstash.conf。在该文件中，可以设置Logstash如何处理数据。例如，可以添加以下内容：<br>input {<br>file {<br>type &#x3D;&gt; “syslog”<br>path &#x3D;&gt; [ “&#x2F;var&#x2F;log&#x2F;messages” ]<br>}<br>}<br>filter {<br>if [type] &#x3D;&#x3D; “syslog” {<br>grok {<br>match &#x3D;&gt; { “message” &#x3D;&gt; “%{SYSLOGTIMESTAMP:syslog_timestamp} %{SYSLOGHOST:syslog_hostname} %{DATA:syslog_program}(?:[%{POSINT:syslog_pid}])?: %{GREEDYDATA:syslog_message}” }<br>}<br>date {<br>match &#x3D;&gt; [ “syslog_timestamp”, “MMM d HH:mm:ss”, “MMM dd HH:mm:ss” ]<br>}<br>}<br>}<br>output {<br>elasticsearch {<br>hosts &#x3D;&gt; [“localhost:9200”]<br>index &#x3D;&gt; “logstash-%{+YYYY.MM.dd}”<br>}<br>}<br>以上配置示例展示了Logstash如何读取系统日志文件&#x2F;var&#x2F;log&#x2F;messages并使用正则表达式解析其中的内容，然后将结果发送到Elasticsearch进行分析和查询。<br>6.启动Logstash<br>保存并关闭文件后，使用以下命令启动Logstash：<br>sudo systemctl start logstash<br>sudo systemctl enable logstash</p><p>Logstash.service缺失<br>如果您需要重新安装 Logstash 或手动创建服务文件，可以参考以下步骤：<br>重新安装 Logstash：<br>如果您使用的是 CentOS 或者 Red Hat 等基于 RPM 的 Linux 发行版，可以使用以下命令重新安装 Logstash：<br>sudo yum remove logstash<br>sudo yum install logstash</p><p>如果您使用的是 Ubuntu 或者 Debian 等基于 APT 的 Linux 发行版，可以使用以下命令重新安装 Logstash：<br>sudo apt-get remove logstash<br>sudo apt-get install logstash</p><p>手动创建服务文件：<br>如果您需要手动创建 Logstash 的服务文件，可以按照以下步骤操作：<br>在<br>&#x2F;etc&#x2F;systemd&#x2F;system&#x2F; 目录下创建一个名为<br>logstash.service 的文件，并添加以下内容：<br>[Unit]<br>Description&#x3D;logstash<br>After&#x3D;network-online.target</p><p>[Service]<br>User&#x3D;logstash<br>Group&#x3D;logstash<br>ExecStart&#x3D;&#x2F;usr&#x2F;share&#x2F;logstash&#x2F;bin&#x2F;logstash –path.settings &#x2F;etc&#x2F;logstash&#x2F;</p><p>[Install]<br>WantedBy&#x3D;multi-user.target</p><p>这个服务文件假设 Logstash 的安装路径为 &#x2F;usr&#x2F;share&#x2F;logstash，配置文件路径为 &#x2F;etc&#x2F;logstash。您可以根据实际情况进行修改。<br>保存该文件后，执行以下命令重新加载 systemd 的配置文件：<br>sudo systemctl daemon-reload</p><p>最后执行以下命令启动并开机自启动 Logstash 服务：<br>sudo systemctl start logstash<br>sudo systemctl enable logstash</p><p>通过以上步骤，应该能够重新安装 Logstash 或手动创建服务文件，并正确启用 Logstash 服务。<br>7.安装Kibana<br>Kibana是一个用于可视化和分析数据的Web界面，可以将Elasticsearch中的数据可视化并提供一些分析功能。可以使用以下步骤安装Kibana：<br>sudo rpm –import <a href="https://artifacts.elastic.co/GPG-KEY-elasticsearch">https://artifacts.elastic.co/GPG-KEY-elasticsearch</a><br>sudo vi &#x2F;etc&#x2F;yum.repos.d&#x2F;kibana.repo<br>复制以下文本到kibana.repo文件中：<br>[kibana-7.x]<br>name&#x3D;Kibana repository for 7.x packages<br>baseurl&#x3D;<a href="https://artifacts.elastic.co/packages/7.x/yum">https://artifacts.elastic.co/packages/7.x/yum</a><br>gpgcheck&#x3D;1<br>gpgkey&#x3D;<a href="https://artifacts.elastic.co/GPG-KEY-elasticsearch">https://artifacts.elastic.co/GPG-KEY-elasticsearch</a><br>enabled&#x3D;1<br>autorefresh&#x3D;1<br>type&#x3D;rpm-md<br>保存并关闭文件后，使用以下命令安装：<br>sudo yum install kibana<br>8.配置Kibana<br>安装完成后，需要编辑Kibana配置文件&#x2F;etc&#x2F;kibana&#x2F;kibana.yml。在该文件中，可以设置Kibana监听的IP地址和端口等参数。例如，可以添加以下内容：<br>server.host: “0.0.0.0”<br>server.port: 5601<br>elasticsearch.hosts: [“<a href="http://localhost:9200”]">http://localhost:9200”]</a><br>保存并关闭文件后，使用以下命令启动Kibana：<br>sudo systemctl start kibana<br>sudo systemctl enable kibana<br>9.访问Kibana<br>现在可以通过http:&#x2F;&#x2F;服务器IP地址:5601访问Kibana。在Kibana的Web界面中，可以配置和运行各种查询和分析操作，以便对Elasticsearch中的数据进行可视化和分析。<br>以上就是在centos环境下部署ELK的全部步骤。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/03/26/hello-world/"/>
    <url>/2025/03/26/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
